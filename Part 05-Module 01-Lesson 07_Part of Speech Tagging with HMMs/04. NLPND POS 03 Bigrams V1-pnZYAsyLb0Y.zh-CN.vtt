WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:03.944
当然查询表不可能始终有用

00:00:03.944 --> 00:00:07.379
再举一个新的示例 这次的句子更加复杂

00:00:07.379 --> 00:00:10.650
数据由以下句子组成

00:00:10.650 --> 00:00:12.315
Mary will see Jane.

00:00:12.314 --> 00:00:13.839
Will will see Mary

00:00:13.839 --> 00:00:15.679
以及 Jane will see Will.

00:00:15.679 --> 00:00:17.355
标记是这样的

00:00:17.355 --> 00:00:19.410
名词 情态动词 动词

00:00:19.410 --> 00:00:21.530
我们的目标是标记句子：

00:00:21.530 --> 00:00:23.100
Mary will see Will.

00:00:23.100 --> 00:00:25.385
我们正常地创建一个查询表

00:00:25.385 --> 00:00:27.015
开始标记句子

00:00:27.015 --> 00:00:29.429
Mary 正确地标记为名词

00:00:29.429 --> 00:00:32.159
will 正确地标记为情态动词

00:00:32.159 --> 00:00:34.739
see 正确地标记为动词

00:00:34.740 --> 00:00:36.130
现在遇到问题了

00:00:36.130 --> 00:00:38.780
Will 始终标记为情态动词

00:00:38.780 --> 00:00:41.774
因为有三次出现为情态动词 两次出现为名词

00:00:41.774 --> 00:00:46.225
但是在这个句子中 我们知道 Will 是名词 因为它指的是好友 Will

00:00:46.225 --> 00:00:48.359
这就是一个问题

00:00:48.359 --> 00:00:52.049
具体而言 如果某个单词有两种不同的标签 则查询表不太好使

00:00:52.049 --> 00:00:53.939
因为无论语境如何

00:00:53.939 --> 00:00:56.085
它始终会选择最常见的相关标记

00:00:56.085 --> 00:00:57.600
现在的问题是

00:00:57.600 --> 00:00:59.579
如何考虑语境

00:00:59.579 --> 00:01:03.869
最简单的方法是查看每个单词的邻近单词

00:01:03.869 --> 00:01:07.049
例如可以对单词对进行标记

00:01:07.049 --> 00:01:09.869
我们将连续单词对

00:01:09.870 --> 00:01:12.840
see-Jane 标记为动词-名词一次

00:01:12.840 --> 00:01:15.719
因为它出现为动词-名词一次

00:01:15.719 --> 00:01:17.924
现在开始标记其他句子

00:01:17.924 --> 00:01:20.560
使用之前的表格标记第一个单词

00:01:20.560 --> 00:01:22.655
将 Mary 标记为名词

00:01:22.655 --> 00:01:24.290
对于后续每个单词

00:01:24.290 --> 00:01:25.895
我们将使用前一个单词和查询表

00:01:25.894 --> 00:01:29.214
查找对应的标记对

00:01:29.215 --> 00:01:31.365
例如 要标记单词 will

00:01:31.364 --> 00:01:34.179
我们看看 Mary-will 其中 Mary 是名词

00:01:34.180 --> 00:01:38.515
最常见的情形是 will 是情态动词

00:01:38.515 --> 00:01:40.614
因此将 will 标记为情态动词

00:01:40.614 --> 00:01:42.670
继续将 see 标记为动词

00:01:42.670 --> 00:01:44.620
将第二个 Will 正确地标记为名词

00:01:44.620 --> 00:01:47.380
因为单词对 see-Will 被标记为动词-名词

00:01:47.379 --> 00:01:49.989
注意我在介绍这个算法时比较模糊

00:01:49.989 --> 00:01:52.734
因为有很多定义细节的方式

00:01:52.734 --> 00:01:54.224
大多数方式都效果不错

00:01:54.224 --> 00:01:56.604
建议你思考一些完善该算法的方式

00:01:56.605 --> 00:02:00.265
例如 可以根据单词本身和前一个单词进行标记

00:02:00.265 --> 00:02:03.060
查询表会纠正前一个单词的标记

00:02:03.060 --> 00:02:05.695
你是保留现有标记 还是使用新的标记？

00:02:05.694 --> 00:02:09.544
这些都是在考虑什么方式最适合数据时需要作出的决策

00:02:09.544 --> 00:02:11.934
当然 双字母组并不是唯一方式

00:02:11.935 --> 00:02:14.289
一次还可以查看三个单词 甚至更多

00:02:14.289 --> 00:02:18.530
这些称之为 Ingram 非常适合词性标注

